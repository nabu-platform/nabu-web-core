# To refactor hidden dimensions & extensions

# the scss should already be compiled at this point
css ?= null
# don't want to recalculate these, just pass them along from the original generate
components ?= null
mixins ?= null

# copy paste from arisGenerate
findExtensions = lambda
	name ?= null
	# start with the actual extensions
	@return
	names = components[component == /name]/name
	# currently max 5 deep?
	for (5)
		childExtensions = components[component ? /names && name !? /names]/name
		if (size(childExtensions) == 0)
			break
		else
			names = merge(names, childExtensions)

# find all hidden dimensions etc
# we include the trailing { to make sure we have a full unique match, not a partial match
# for instance if a particular rule is simply "more specific", it would match the beginning, but not the end
hidden = unique(find("(?s)(?:^|})[\s]*([^}{]*:is-[^{]+\{)", css))
for (single : hidden)
	replacement = single
	# we replace one item at a time, but there may be multiple items to replace, e.g. this will require two loops:
	# .is-form .is-this:is-form-component :is-form-label
	# we don't want to re-find from the css every time as this is too intensive (regex on massive strings...)
	# so instead we iterate on each line until it is fully resolved
	while (replacement ~ ".*:is-.*")
		# we keep track of the original, if you for instance reference a component that is unknown, it will never be resolved
		# we don't want to loop indefinitely
		original = replacement
		
		# we do an initial check for things like :where(:is-layout). we want a different kind of explosion there
		names = unique(find(":where\(:is-([^)]+)\)", replacement))
		for (name : names)
			resultingExtensions = merge(name, findExtensions(name))
			resultingExtensions = ".is-" + resultingExtensions
			replacement = replace(
				quoteRegex(":where(:is-" + name + ")"),
				quoteReplacement(":where(" + join(", ", resultingExtensions) + ")"),
				replacement)
		
		# can have multiple combined, like :is-button:has-border-pill
		# we need to explode it then...
		names = unique(find(":is-([\w-]+)", replacement))
		# at this point we don't want to use where because you specifically typed it, you probably want the specificity
		for (name : names)
			# if it is a component of any type, we must take that and all its extension
			if (name ? components/name)
				resultingExtensions = findExtensions(name)
				# optimize away the :is() if not necessary
				if (size(resultingExtensions) == 0)
					replacement = replace(":is-" + name, ".is-" + name, replacement)
				else
					replacement = replace(":is-" + name, ":is(" + join(", ", ".is-" + merge(name, resultingExtensions)) + ")", replacement)

		if (original == replacement)
			break
		
	# we want to replace dimensions
	# for example we might have :is-form-component:is-border-underline
	# the problem with dimensions is that they can be encapsulated in variants, at which point they won't explicitly appear as a css class
	# so we want to make sure we target the dimension itself, e.g. ".is-border-underline", so ".is-form-text.is-border-underline"
	# but maybe we have a variant of the component that embeds it, we want to target that as well ".is-form-text.is-variant-embedded-underline
	# a dimensions is only useful if it is combined with the component, which means the component is always available in the selector
	# at this point the component has already been exploded, so we have exact components
	# if we have a standalone ":is-border-underline", it won't do much anyway in css so we don't care about it here
	# our assumption is that the component is always the first "is" selector, that is how it is generated by the aris framework and even when writing manual css it is the most likely approach
	
	# before we process dimensions that are at the base depth
	# e.g. .is-form:is-dimension-option
	# we want to deal with exploded versions where :is or :where is applicable
	# e.g. :is-form:is-dimension-option
	# is already exploded in the above to become :is(.is-form):is-dimension-option
	explodedReferences = find("(?::where|:is)[\s]*\([\s]*([^)]+\):is-[\w-]+)", replacement)
	for (explodedReference : unique(explodedReferences))
		# we left the closing one in there which can now be used as a seperator
		parts = trim(split("\)", explodedReference))
		# the first part is a comma separated list, this "should" mostly (only?) contain component selectors like .is-form etc
		componentSelectors = replace("\.is-", "", find("\.is-.*", split("[\s]*,[\s]*", parts[0])))
		dimension = replace(".*:is-([\w-]+).*", "$1", parts[1])
		allVariants = series()
		for (component : componentSelectors)
			# we want to check for variants of that component that embed the dimension
			applicableVariants = mixins[name ~ /component + "-variant-.*" && body ~ "(?s).*@include[\s]+[\w-]+-" + /dimension + "[\s]*;.*"]/name
			# we want to remove the name of the component and just retain ".is-variant-something"
			applicableVariants = replace(".*-(variant-.*)", "$1", applicableVariants)
			allVariants = unique(merge(allVariants, applicableVariants))
			
		# we avoid the more complex :is() selector if it is not needed
		if (size(allVariants) == 0)
			replacement = replace(
				quoteRegex(explodedReference),
				quoteReplacement(parts[0] + ").is-" + dimension), 
				replacement)
		else
			replacement = replace(
				quoteRegex(explodedReference),
				quoteReplacement(parts[0] + "):is(" + join(", ", ".is-" + merge(dimension, allVariants)) + ")"), 
				replacement)
	
	# we don't want to mess with remaining :where() or :is() selectors, they have embedded "," separators, easiest way to do that is just replace it with a placeholder
	# we do want to keep other selectors that might be interesting, like :not() etc
	# this may have to be extended however if other collisions occur
	clauses = unique(find("(?::where|:is)[\s]*\([^)]*\)", replacement))
	for (clause : clauses)
		replacement = replace(quoteRegex(clause), "&" + $index, replacement)
	
	while (replacement ~ ".*:is-.*")
		original = replacement
		
		dimensionReferences = unique(find("(?m)(?:^|,|[\s]+|\))(.is-[^,\s]+:is-[^,\s]+)", replacement))
		for (dimensionReference : dimensionReferences)
			component = replace("^.is-([\w-]+).*", "$1", dimensionReference)
			dimension = replace(".*:is-([\w-]+).*", "$1", dimensionReference)
			# we want to check for variants of that component that embed the dimension
			applicableVariants = mixins[name ~ /component + "-variant-.*" && body ~ "(?s).*@include[\s]+[\w-]+-" + /dimension + "[\s]*;.*"]/name
			# we want to remove the name of the component and just retain ".is-variant-something"
			applicableVariants = replace(".*-(variant-.*)", "$1", applicableVariants)
			
			# optimize away the :is if not necessary
			if (size(applicableVariants) == 0)
				replacement = replace(":is-" + dimension, ".is-" + dimension, replacement)
			else
				replacement = replace(":is-" + dimension, ":is(" + join(", ", ".is-" + merge(dimension, applicableVariants)) + ")", replacement)
			
		
		# of course we also just want to target the dimension
		if (original == replacement)
			#console("Could not fully resolve references, might be missing some css: " + original)
			break
	
	# we resolve any remaining ":is-" references into a class, maybe you just want to be sure no one implements it
	replacement = replace(":is-", ".is-", replacement)

	# replace again	
	for (clause : clauses)
		replacement = replace(quoteRegex("&" + $index), quoteReplacement(clause), replacement)
	
	# for dimensions we use the "has" syntax, so "has-border-pill"
	# so the problem for dimensions is that variants encapsulate them
	# .is-button:has-color-primary will match .is-button.is-color-primary but should also be applied to .is-button.is-variant-primary
		
	css = replace(
		quoteRegex(single), 
		quoteReplacement(replacement),
		css)