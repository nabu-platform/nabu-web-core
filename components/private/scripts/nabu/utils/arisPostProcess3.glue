# To refactor hidden dimensions & extensions

# the scss should already be compiled at this point
css ?= null
# don't want to recalculate these, just pass them along from the original generate
components ?= null
mixins ?= null

# copy paste from arisGenerate
findExtensions = lambda
	name ?= null
	# start with the actual extensions
	@return
	names = components[component == /name]/name
	# currently max 5 deep?
	for (5)
		childExtensions = components[component ? /names && name !? /names]/name
		if (size(childExtensions) == 0)
			break
		else
			names = merge(names, childExtensions)

# find all hidden dimensions etc
# we include the trailing { to make sure we have a full unique match, not a partial match
# for instance if a particular rule is simply "more specific", it would match the beginning, but not the end
hidden = unique(find("(?s)(?:^|})[\s]*([^{]*:is-[^{]+\{)", css))
for (single : hidden)
	replacement = single

	# we replace one item at a time, but there may be multiple items to replace, e.g. this will require two loops:
	# .is-form .is-this:is-form-component :is-form-label
	# we don't want to re-find from the css every time as this is too intensive (regex on massive strings...)
	# so instead we iterate on each line until it is fully resolved
	while (replacement ~ ".*:is-.*")
		# we keep track of the original, if you for instance reference a component that is unknown, it will never be resolved
		# we don't want to loop indefinitely
		original = replacement
		
		# we do an initial check for things like :where(:is-layout). we want a different kind of explosion there
		names = unique(find(":where\(:is-([^)]+)\)", replacement))
		for (name : names)
			resultingExtensions = merge(name, findExtensions(name))
			resultingExtensions = ".is-" + resultingExtensions
			replacement = replace(
				quoteRegex(":where(:is-" + name + ")"),
				quoteReplacement(":where(" + join(", ", resultingExtensions) + ")"),
				replacement)
		
		# we remove the trailing { which we added to guarantee an exact match in final replacement
		# however we might need to duplicate this line multiple times and we only want one trailing { in the result
		# there might be multiple selectors in the line, we are only interested in duplicating the ones that have the reference
		# we _have_ to remove the whitespace on split, otherwise on each iteration we will keep adding whitespace at which point original will never equal replacement
		replacements = split("[\s]*,[\s]*", replace("[\s]*\{", "", replacement))
		
		# can have multiple combined, like :is-button:has-border-pill
		# we need to explode it then...
		names = unique(find(":is-([\w-]+)", replacement))
		for (name : names)
			# if it is a component of any type, we must take that and all its extension
			if (name ? components/name)
				resultingExtensions = findExtensions(name)
				# we don't want to duplicate parts that do not have the reference, so store them here
				result = replacements[$this !~ ".*:is-" + /name + ".*"]
				# remove them from the list of replacements
				replacements = replacements[$this !? /result]
				# duplicate the replacements for each iteration
				for (component : merge(name, resultingExtensions))
					result = merge(result, replace(":is-" + name, ".is-" + component, replacements))
				replacements = result
				
		replacement = join(", ", replacements) + " {"
		if (original == replacement)
			break
		
	# we want to replace dimensions
	# for example we might have :is-form-component:is-border-underline
	# the problem with dimensions is that they can be encapsulated in variants, at which point they won't explicitly appear as a css class
	# so we want to make sure we target the dimension itself, e.g. ".is-border-underline", so ".is-form-text.is-border-underline"
	# but maybe we have a variant of the component that embeds it, we want to target that as well ".is-form-text.is-variant-embedded-underline
	# a dimensions is only useful if it is combined with the component, which means the component is always available in the selector
	# at this point the component has already been exploded, so we have exact components
	# if we have a standalone ":is-border-underline", it won't do much anyway in css so we don't care about it here
	# our assumption is that the component is always the first "is" selector, that is how it is generated by the aris framework and even when writing manual css it is the most likely approach
	
	# we don't want to mess with :where() or :is() selectors, they have embedded "," separators, easiest way to do that is just replace it with a placeholder
	clauses = unique(find("(?::where|:is)[\s]*\([^)]*\)", replacement))
	for (clause : clauses)
		replacement = replace(quoteRegex(clause), "&" + $index, replacement)
	
	while (replacement ~ ".*:is-.*")
		original = replacement
		
		# again we strip the trailing {
		replacements = split("[\s]*,[\s]*", replace("[\s]*\{", "", replacement))
		
		dimensionReferences = unique(find("(?m)(?:^|,|[\s]+|\))(.is-[^,\s]+:is-[^,\s]+)", replacement))
		for (dimensionReference : dimensionReferences)
			component = replace("^.is-([\w-]+).*", "$1", dimensionReference)
			dimension = replace(".*:is-([\w-]+).*", "$1", dimensionReference)
			# we want to check for variants of that component that embed the dimension
			applicableVariants = mixins[name ~ /component + "-variant-.*" && body ~ "(?s).*@include[\s]+[\w-]+-" + /dimension + "[\s]*;"]/name
			# we want to remove the name of the component and just retain ".is-variant-something"
			applicableVariants = replace(".*-(variant-.*)", "$1", applicableVariants)
			# we don't want to duplicate parts that do not have the reference, so store them here
			result = replacements[$this !~ ".*" + /dimensionReference + ".*"]
			# remove them from the list of replacements
			replacements = replacements[$this !? /result]
			# we want to add a copy for the original dimension and any variant that embeds it
			for (singleVariant : merge(dimension, applicableVariants))
				result = merge(result, replace(quoteRegex(":is-" + dimension), quoteReplacement(".is-" + singleVariant), dimensionReference))
			replacements = result
				
		replacement = join(", ", replacements) + " {"
		
		# of course we also just want to target the dimension
		if (original == replacement)
			#console("Could not fully resolve references, might be missing some css: " + original)
			break
	
	# we resolve any remaining ":is-" references into a class, maybe you just want to be sure no one implements it
	replacement = replace(":is-", ".is-", replacement)

	# replace again	
	for (clause : clauses)
		replacement = replace(quoteRegex("&" + $index), quoteReplacement(clause), replacement)
	console("replacing in", replacement)
	
	# for dimensions we use the "has" syntax, so "has-border-pill"
	# so the problem for dimensions is that variants encapsulate them
	# .is-button:has-color-primary will match .is-button.is-color-primary but should also be applied to .is-button.is-variant-primary
		
	css = replace(
		quoteRegex(single), 
		quoteReplacement(replacement),
		css)