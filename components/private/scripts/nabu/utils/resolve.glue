file ?= "bundle.json"
json ?= when(file ? resources(),
	json.objectify(resource(file), true),
	json.objectify(read("repository:" + environment("webApplicationId") + ":/private/" + file), true))
target ?= when(file ? resources(),
	system.pwd(),
	"repository:" + environment("webApplicationId") + ":/private/scripts/bundles")
boolean force ?= environment("development") == true && request.get("force") == true
regex ?= ".*\.js"
string [] scopes ?= null
# whether or not to print the resulting resources
boolean print ?= true
# whether or not we should put everything on the root
boolean root ?= false

#registry ?= "http://registry.npmjs.org"

resolveRequires = lambda
	json ?= null
	requires ?= null

	@return
	result = structure()
	for (key : keys(requires))
		context = requires[/key]
		if (context/self != null)
			scope = json/scopes[/context/self]
			result = structure(result, lambda(key): scope[/key])
		else
			result = structure(result, lambda(key): context)

# encodes templates to be more IE-compatible
replacer = nabu.utils.lambdas()/templater

inject(scope(1))

# included remote bundle.json files should _only_ have the scope dependencies, all other scopes are ignored
resolveJson = lambda
	target ?= null
	json ?= null
	string [] scopes ?= null
	includes ?= series()
	excludes ?= series()
	
	@return
	resolved ?= series()
	
	boolean root ?= false
	
	bundleEndpoint ?= null
	
	bundleNamespace ?= null
	bundleName ?= null
	bundleVersion ?= null
	
	if (json/variables != null)
		inject(json/variables)
	
	for (scope : keys(json/scopes))
		if (scopes == null || size(scopes) == 0 || scope ? scopes)
			for (dependency : keys(json/scopes[/scope]))
				scopeContent = json/scopes[/scope]
				context = scopeContent[/dependency]
				type = when(context/type != null, context/type, json/scopes[/scope]/type)
				# default type is "file" which we only resolve if necessary
				# modules always have to be recursively resolved
				if ((dependency !? excludes && (size(includes) == 0 || dependency ? includes) && dependency ~ regex) || type == "bundle")
					dependencyTarget = when(context/folder == null, target, target + "/" + context/folder) + when(root, "", "/" + dependency)
					
					if (type == "bundle")
						dependencyTarget = dependencyTarget + when(root, "/bundle-" + dependency + ".json", "/bundle.json")
						
					# whether or not we should include it in the output
					# the only reason not to is if it was already resolved before
					include = true
					# calculate the url to see if we have already included it
					# you are resolving from a remote location (github, cdn,...)
					if (context/url != null)
						# make sure we can detect when content was not loaded and not accidently use previous content
						content = null
						
						# inject the context so you can use variables in the url
						inject(context)
						# template the url
						url = template(context/url)
						
						# if it's not absolute, make it so
						if (url !~ "^[\w]+:.*" && bundleEndpoint != null)
							url = replace("[^/]+$", "", bundleEndpoint) + url
							
						if (url ? resolved/url || size(resolved[bundleNamespace = /bundleNamespace && bundleName = /bundleName && name = /dependency && scope = /scope]) > 0)
							console("Skipping previously resolved dependency: " + dependency + " [" + url + "]")
							include = false
						else
							# only update it if we force it or it doesn't exist yet
							if (force || !exists(dependencyTarget))
								console("Downloading dependency: " + dependency + " [" + url + "]")
								# get the content
								content = read(url)
								# write the content to the target
								write(dependencyTarget, content)
							else
								console("Skipping existing dependency: " + dependency + " [" + url + "]")
								
							# always add it to resolved, whether or not it was (re)downloaded
							resolved = merge(resolved, structure(
									url: url,
									target: dependencyTarget,
									dependency: dependency,
									bundleNamespace: bundleNamespace,
									bundleName: bundleName,
									name: dependency,
									scope: scope
								))
						# get the correct resolution
						correct = first(resolved[url = /url])
						if (type == "bundle")
							# if you have items that are from an already imported bundle but not imported themselves (e.g. different scope or excluded/not included)
							# the question is, do you want to resolve them in the location of the original bundle
							# or in the location of the current bundle
							# currently we opt for the latter as it makes it more clear who imports what
							resolved = merge(resolved, resolveJson(replace("/bundle[^/]*.json$", "", dependencyTarget), json.objectify(read(correct/target), true), context/scopes, context/includes, context/excludes, resolved, root: false,
								bundleEndpoint: url,
								bundleNamespace: json/namespace,
								bundleName: json/name,
								bundleVersion: json/version))
						else if (include && print)
							if (dependency ~ ".*\.gcss")
								gcss = function(replace("/", ".", target) + "." + replace(".gcss", "", correct/dependency))
								gcss = bind(gcss, scope())
								gcss()
							else if (dependency ~ ".*\.tpl")
								if (context/template != null && context/template)
									echo(template(replacer(read(resource))))
								else
									echo(replacer(read(resource)))
							else
								if (context/template != null && context/template)
									echo(template(read(correct/target), "\n"))
								else
									echo(read(correct/target), "\n")
								
					# a context can have requires which _must_ be resolved
					if (context/requires != null)
						# we create a bundle on the fly with one scope: requires
						# we then add the requirements in it so they can be resolved
						# include the original variables so you can refer to them
						resolved = merge(resolved, 
							resolveJson(target, structure(variables: json/variables, scopes: structure(requires: resolveRequires(json, context/requires))), resolved: resolved, root: false,
								bundleEndpoint: when(type == "bundle", url, bundleEndpoint)))						
			
resolveJson(target, json, scopes, root: root)