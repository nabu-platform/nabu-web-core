## lessons learned:
## - support relative paths for resources (can do a checkout, work on private repos etc) and everything keeps working
## - support namespace, name and stuff so we can identify a resource without knowing its true url
## - need solution for "load order" if at all possible...
## - need clean way to load themes...
## - very verbose description for now, is it necessary?
## - hard to target one specific thing, for example a single component (with related js/tpl/gcss files is a sub folder)
## - includes/excludes are hard to work with in combination with scopes, scopes don't have blacklist...
## - hard to pinpoint something exactly, might need to go full path, simply map the filesystem in the json
## - need way to target where resources are stored so we can include (e.g.) static resources

# input
sequence
	target ?= "repository:" + environment("webApplicationId") + ":/private/provided/artifacts"
	string regex ?= ".*\.js"
	boolean force ?= environment("development") == true && request.get("force") == true
	
	# whether or not to print the resulting resources
	boolean print ?= true
	
	# whether or not we should put everything on the root
	boolean root ?= false
	
	# you can whitelist or blacklist paths
	string [] includes ?= series()
	string [] excludes ?= series()
	
	# whether to inject everything on the root of the target
	boolean root ?= false
	
	# whether to print out debugging information
	boolean debug ?= false

# load bundle
sequence
	bundlePath ?= "repository:" + environment("webApplicationId") + ":/private/provided/bundle.json"
	if (!exists(bundlePath))
		throw("Could not find bundle.json at: " + bundlePath)
	
	json ?= json.objectify(read(bundlePath), raw: true)

# lambda to resolve required dependencies
resolveRequires = lambda
	json ?= null
	requires ?= null

	@return
	result = structure()
	for (key : keys(requires))
		context = requires[/key]
		if (context/self != null)
			scope = json/scopes[/context/self]
			result = structure(result, lambda(key): scope[/key])
		else
			result = structure(result, lambda(key): context)

# encodes templates to be more IE-compatible
replacer = nabu.utils.lambdas()/templater

# inherit the variables from the parent scope so they can be injected
parentScope = scope(1)

result = structure()

log = lambda(x, when(debug, console(x)))

resolveResources = method
	# the bundle context we are working with, this contains:
	# namespace
	# name
	# target: where we are writing to (is updated for each recursion)
	# path: the current path we are working on (is updated for each recursion)
	# includes: the includes that were registered
	# excludes: the excludes that were registered
	# endpoint: the endpoint of the bundle itself (to resolve relative urls)
	bundleContext ?= null
	
	# the resources we are working with
	resources ?= null

	# this script takes the already resolved scripts and adds its own	
	# each resolved item contains:
	# - namespace
	# - name
	# - path: the path in the original bundle to uniquely identify it
	# - target: where it was written so we can re-read it if necessary
	# - url: the url it was picked up from
	resolved ?= series()
	
	# the newly resolved items, these are sent back to be appended to the ever growing list of items
	newlyResolved ?= series()
	
	boolean root ?= false

	result ?= structure()

	for (key : keys(resources))
	
		childPath = when(bundleContext/path == null, key, bundleContext/path + "/" + key)
		childTarget = bundleContext/target + "/" + key
		
		# check that it passes the whitelist
		continue = size(bundleContext/includes) == 0 || childPath ? bundleContext/includes || true ? (childPath ~ (bundleContext/includes + "/.*"))
		
		# check that it passes the blacklist
		if (continue)
			continue = size(bundleContext/excludes) == 0 || (childPath !? bundleContext/excludes && true !? (childPath ~ (bundleContext/excludes + "/.*")))
			
		if (continue)
			# the current resource
			resource = resources[/key]
			
			if (resource/requires != null)
				resolveResult = resolveResources(
						bundleContext: bundleContext,
						resources: resource/requires,
						resolved: resolved,
						result: result)
					
					# feedback any changes to the resulting scope
					result = resolveResult/result
					
					# feedback any newly resolved items
					resolved = merge(resolved, resolveResult/newlyResolved)
			
			# if we have an actual resource, not a container, let's do something
			if (resource/url != null)
				log("Resolving " + bundleContext/name + ": " + childPath)		
				
				# only use the resource if it matches the regex or it is a bundle which we have to recurse
				if (key ~ regex || resource/type == "bundle")
				
					# the content of the resource, it is not always necessary so explicitly set it to null to detect whether it's there
					content = null
					
					# the resolved for this child, check if one already exists
					childResolved = first(resolved[namespace = /bundleContext/namespace && name = /bundleContext/name && path = /childPath])
					
					# whether or not to inject the content, only inject it the first time (so if it has not yet been resolved)
					include = childResolved == null
					
					# if we already resolved it, skip
					if (childResolved != null)
						log("\tSkipping because previous resolved: " + childResolved/target)
						
					# only update it if we force it or it doesn't exist yet
					else
						# always calculate the url so we can add it to the resolved
						# this url will serve (for bundles for example) as a point for relative paths to start from
						url = resource/url
						# if it's not absolute, make it so
						if (url !~ "^[\w]+:.*" && bundleContext/endpoint != null)
							url = replace("//", "/", replace("[^/]+$", "", bundleContext/endpoint) + "/" + url)
	
						# if we are in development mode, check the last modified of the target resource
						lastModified = when(environment("development") == true, modified(url), null)
						
						if (force || !exists(childTarget) || when(lastModified == null, false, lastModified > modified(childTarget)))
							log("\tReading from: " + url)
							# get the content
							content = file.read(url)
	
							log("\tWriting to: " + childTarget)
							# write the content to the target
							file.write(childTarget, content)
						else
							log("\tSkipping because it exists: " + childTarget)
							
						# set the child resolved
						childResolved = structure(
							namespace: bundleContext/namespace,
							name: bundleContext/name,
							path: childPath,
							target: childTarget,
							url: url)
							
						# add it to resolved
						resolved = merge(resolved, childResolved)
						
						# if we have content at this stage, we resolved it
						if (content != null)
							newlyResolved = merge(newlyResolved, childResolved)
				
					# if we have a bundle, always resolve further				
					if (resource/type == "bundle")
						# it is possible we did not read the content in the above
						if (content == null)
							content = read(childResolved/target)
							
						# parse the content
						referenced = json.objectify(content, raw: true)
						
						# if you have items that are from an already imported bundle but not imported themselves (e.g. different scope or excluded/not included)
						# the question is, do you want to resolve them in the location of the original bundle
						# or in the location of the current bundle
						# currently we opt for the latter as it makes it more clear who imports what
						resolveResult = resolveResources(
							bundleContext: structure(
								namespace: referenced/namespace,
								name: referenced/name,
								target: when(root, bundleContext/target, replace("\.json$", "", childTarget)),
								includes: resource/includes,
								excludes: resource/excludes, 
								endpoint: childResolved/url),
							resources: referenced/resources,
							resolved: resolved,
							result: result)
						
						# feedback any changes to the resulting scope
						result = resolveResult/result
						
						# feedback any newly resolved items
						resolved = merge(resolved, resolveResult/newlyResolved)
							
					else if (include && print)
						if (key ~ ".*\.(gcss|glue)")
							scriptName = replace(".*?/private/provided/artifacts/", "", childResolved/target)
							scriptName = replace("/", ".", replace("\.(gcss|glue)", "", scriptName))
							script = function(scriptName)
							
							if (script == null)
								throw("Could not find script: " + scriptName)
								
							script = bind(script, parentScope)
							result = structure(result, script())
							
						else if (childResolved/target ~ ".*\.tpl")
							if (resource/template == null || resource/template == true)
								echo(template(replacer(read(childResolved/target)), parentScope))
							else
								echo(replacer(read(childResolved/target)))
						else
							if (resource/template == null || resource/template == true)
								try
									echo(template(read(childResolved/target), parentScope), "\n")
									catch
										console("Could not template " + childResolved/target, resource)
							else
								echo(read(childResolved/target), "\n")
					
			# if we have a container, recurse
			else
				# pass along the root if we are just going through dirs, only a new bundle breaks this root requirement
				resolveResult = resolveResources(
					bundleContext: structure(bundleContext,
						path: when(resource/type == "bundle", replace("\.json$", "", childPath), childPath),
						target: when(root, bundleContext/target, childTarget)),
					resources: resource,
					resolved: resolved,
					root: root,
					result: result)
					
				# feedback any changes to the resulting scope
				result = resolveResult/result
				
				# feedback any newly resolved items
				resolved = merge(resolved, resolveResult/newlyResolved)
		
resolveResult = resolveResources(
	bundleContext: structure(
		namespace: json/namespace,
		name: json/name,
		target: target,
		includes: includes,
		excludes: excludes,
		endpoint: bundlePath),
	resources: json/resources,
	root: root,
	result: result)
	
# feedback any changes to the resulting scope
result = resolveResult/result