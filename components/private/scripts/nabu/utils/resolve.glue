file ?= "bundle.json"
json ?= when(file ? resources(),
	json.objectify(resource(file), true),
	json.objectify(read("repository:" + environment("webApplicationId") + ":/private/" + file), true))
target ?= when(file ? resources(),
	system.pwd(),
	"repository:" + environment("webApplicationId") + ":/private/scripts/bundles")
boolean force ?= environment("development") == true && request.get("force") == true
registry ?= "http://registry.npmjs.org"
regex ?= ".*\.js"
string [] scopes ?= null

resolveRequires = lambda
	json ?= null
	requires ?= null

	@return
	result = structure()
	for (key : keys(requires))
		context = requires[/key]
		if (context/self != null)
			scope = json/scopes[/context/self]
			result = structure(result, lambda(key): scope[/key])
		else
			result = structure(result, lambda(key): context)

# included remote bundle.json files should _only_ have the scope dependencies, all other scopes are ignored
resolveJson = lambda
	target ?= null
	json ?= null
	string [] scopes ?= null
	includes ?= series()
	excludes ?= series()
	
	@return
	resolved ?= series()
	
	if (json/variables != null)
		inject(json/variables)
	
	for (scope : keys(json/scopes))
		if (scopes == null || size(scopes) == 0 || scope ? scopes)
			for (dependency : keys(json/scopes[/scope]))
				scopeContent = json/scopes[/scope]
				context = scopeContent[/dependency]
				type = when(context/type != null, context/type, json/scopes[/scope]/type)
				# default type is "file" which we only resolve if necessary
				# modules always have to be recursively resolved
				if ((dependency !? excludes && (size(includes) == 0 || dependency ? includes) && dependency ~ regex) || type == "bundle")
					dependencyTarget = when(context/folder == null, target + "/" + dependency, target + "/" + context/folder + "/" + dependency)
					
					if (type == "bundle")
						dependencyTarget = dependencyTarget + "/bundle.json"
						
					# whether or not we should include it in the output
					# the only reason not to is if it was already resolved before
					include = true
					# calculate the url to see if we have already included it
					# you are resolving from a remote location (github, cdn,...)
					if (context/url != null)
						# make sure we can detect when content was not loaded and not accidently use previous content
						content = null
						# inject the context so you can use variables in the url
						inject(context)
						# template the url
						url = template(context/url)
						if (url ? resolved/url)
							console("Skipping previously resolved dependency: " + dependency + " [" + url + "]")
							include = false
						else
							# only update it if we force it or it doesn't exist yet
							if (force || !exists(dependencyTarget))
								console("Downloading dependency: " + dependency + " [" + url + "]")
								# get the content
								content = read(url)
								# write the content to the target
								write(dependencyTarget, content)
							else
								console("Skipping existing dependency: " + dependency + " [" + url + "]")
								
							# always add it to resolved, whether or not it was (re)downloaded
							resolved = merge(resolved, structure(
									url: url,
									target: dependencyTarget,
									dependency: dependency
								))
						# get the correct resolution
						correct = first(resolved[url = /url])
						if (type == "bundle")
							# if you have items that are from an already imported bundle but not imported themselves (e.g. different scope or excluded/not included)
							# the question is, do you want to resolve them in the location of the original bundle
							# or in the location of the current bundle
							# currently we opt for the latter as it makes it more clear who imports what
							resolved = merge(resolved, resolveJson(replace("/bundle.json$", "", dependencyTarget), json.objectify(read(correct/target), true), context/scopes, context/includes, context/excludes, resolved))
						else if (include)
							if (dependency ~ ".*\.gcss")
								gcss = function(replace("/", ".", target) + "." + replace(".gcss", "", correct/dependency))
								gcss = bind(gcss, scope())
								gcss()
							else
								echo(read(correct/target), "\n")
								
					# a context can have requires which _must_ be resolved
					if (context/requires != null)
						# we create a bundle on the fly with one scope: requires
						# we then add the requirements in it so they can be resolved
						# include the original variables so you can refer to them
						resolved = merge(resolved, 
							resolveJson(target, structure(variables: json/variables, scopes: structure(requires: resolveRequires(json, context/requires))), resolved: resolved))						
			
resolveJson(target, json, scopes)