# first we output all the components, like .is-button
# then we output all the variants, we use :where() if multiple variants with the same name exist across component, otherwise it is at the root
# then we output all dimensions, we use :where() if multiple dimensions exist with the same name


fullContent ?= null
lambda generator ?= null

components = series()
for (component : find("//.*@(?:extension|component|pattern)[\s]+(.*)", fullContent))
	parts = split("[\s]+", component)
	components = merge(components, structure(name: parts[0], component: parts[1]))

# this is rather nasty, it assumes the mixin has proper whitespacing because the ending } is assumped to be right after a new line
# it is in lieu of more expensive processing which is currently out of scope
mixins = find("(?s)@mixin.*?\{.*?\n\}", fullContent)

mixins = series.resolve(derive(lambda(mixin, structure(
		name: replace("(?s)@mixin[\s]*([^{\s]+).*", "$1", mixin),
		body: trim(replace("(?s)^[^{]+\{(.*)\}[^}]*$", "$1", mixin))
	)), mixins))
	
splitter = lambda
	mixin ?= null
	split = split("_", mixin/name)
	@return
	parts = structure(
		component: split[0],
		dimension: split[1],
		option: join("_", offset(2, split)))

mixins = series.resolve(derive(lambda(mixin, structure(
		mixin,
		splitter(mixin)
	)), mixins))
	
findExtensions = lambda
	name ?= null
	# start with the actual extensions
	@return
	names = components[component == /name]/name
	# currently max 5 deep?
	for (5)
		childExtensions = components[component ? /names && name !? /names]/name
		if (size(childExtensions) == 0)
			break
		else
			names = merge(names, childExtensions)

useDefaults = false
defaults = series("h1", "h2", "h3", "h4", "h5", "h6", "p", "button")

# while looping we also build a map of all the variants and dimensions
variants = series()
dimensions = series()
modifiers = series()
counting = structure()

# generate the base component classes
for (component : components)
	# get the default variant (if any)
	default = first(mixins[component == /component/name && dimension == "variant" && option == "default"])
	
	# if we have a default, we initiate the component
	if (default != null)
		defaultSelector = when(useDefaults && component/name ? defaults, ", " + component/name, "")
		echo(".is-" + component/name + defaultSelector + " {")
		echo("\t@include " + default/name + ";")
		echo("}")
	
	variantNames = series()
	for (mixin : mixins[component == /component/name])
		dimension = mixin/dimension
		
		if (dimension != "modifier")
			option = mixin/option
			# separated with - means more depth
			# for instance the dimension spacing might have "xsmall" at depth 0
			# more specific it might have horizontal-xsmall at depth 1
			# and beyond that horizontal-left-xsmall at depth 2 etc
			# the idea is that you can take deeper ones to override specific parts of more generic ones so they have to be defined in the correct order
			depth = size(option) - size(replace("-", "", option))
			
			result = structure(
				mixin, 
				component: component/name, 
				dimension: dimension,
				option: option,
				depth: depth)
	
			# dedicated dimension
			if (dimension == "variant")
				variants = merge(variants, result)
				variantNames = merge(variantNames, option)
			else if (dimension == "modifier")
				modifiers = merge(modifiers, result)
			else
				dimensions = merge(dimensions, result)
				
			current = counting[/dimension + "-" + /option]
			counting = structure(counting, lambda(dimension + "-" + option): when(current == null, 1, current + 1))
		else
			console("The dimension 'modifier' is reserved and should not be used")
	
	# we check for modifiers for each of the variants
	for (variant : merge(variantNames))
		for (mixin : mixins[component == /component/name + "-" + /variant && dimension == "modifier"])
			option = mixin/option
			# modifiers don't actually have the name "modifier" in css, so we drop the dimension name
			# in rare cases it might still conflict with a valid dimension-option composition so we need to keep track of it
			current = counting[/option]
			counting = structure(counting, lambda(option): when(current == null, 1, current + 1))
			modifiers = merge(modifiers, structure(
				mixin,
				component: component/name,
				variant: variant,
				modifier: option))


# sort dimensions according to depth
dimensions = sort(lambda(a, b, a/depth - b/depth), dimensions)

# we want the same logic for both variants and dimensions (but in that specific order), might as well do it like this...
for (series : series(variants, dimensions))
	for (single : series)
		# the default option is reserved
		if (single/dimension != "variant" || single/option != "default")
			# if we have multiple parts with the same name, we have to use a where() to specify further
			if (counting[/single/dimension + "-" + /single/option] > 1)
				echo(":where(:is-" + single/component + ").is-" + single/dimension + "-" + single/option + " {")
			else
				echo(".is-" + single/dimension + "-" + single/option + " {")
			echo("\t@include " + single/name + ";")
			echo("}")

# we can have modifiers on variants, let's check for those as well
for (modifier : modifiers)
	if (modifier/variant == "default")
		if (counting[/modifier/modifier] > 1)
			echo(":where(:is-" + modifier/component + ").is-" + modifier/modifier + " {")
		else
			echo(".is-" + modifier/modifier + " {")
	else
		if (counting[/modifier/modifier] > 1)
			echo(":where(:is-" + modifier/component + ".is-variant-" + modifier/variant + ").is-" + modifier/modifier + " {")
		else
			echo(".is-" + modifier/modifier + " {")
			
	echo("\t@include " + modifier/name + ";")
	echo("}")